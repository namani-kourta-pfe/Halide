#ifndef bilateral_grid_auto_schedule_SCHEDULE_H
#define bilateral_grid_auto_schedule_SCHEDULE_H

// MACHINE GENERATED -- DO NOT EDIT
// This schedule was automatically generated by Mullapudi2016
// for target=x86-64-linux-avx-avx2-f16c-fma-sse41  // NOLINT
// with machine_params=16,16777216,40

#include "Halide.h"


inline void apply_schedule_bilateral_grid_auto_schedule(
    ::Halide::Pipeline pipeline,
    ::Halide::Target target
) {
    using ::Halide::Func;
    using ::Halide::MemoryType;
    using ::Halide::RVar;
    using ::Halide::TailStrategy;
    using ::Halide::Var;
    Var x_i("x_i");
    Var x_i_vi("x_i_vi");
    Var x_i_vo("x_i_vo");
    Var x_o("x_o");
    Var x_vi("x_vi");
    Var x_vo("x_vo");
    Var y_i("y_i");
    Var y_o("y_o");

    Func bilateral_grid = pipeline.get_func(8);
    Func blurx = pipeline.get_func(5);
    Func blury = pipeline.get_func(6);
    Func blurz = pipeline.get_func(4);
    Func histogram = pipeline.get_func(3);

    {
        Var x = bilateral_grid.args()[0];
        Var y = bilateral_grid.args()[1];
        bilateral_grid
            .compute_root()
            .split(x, x_o, x_i, 256)
            .split(y, y_o, y_i, 256)
            .reorder(x_i, y_i, x_o, y_o)
            .split(x_i, x_i_vo, x_i_vi, 8)
            .vectorize(x_i_vi)
            .parallel(y_o)
            .parallel(x_o);
    }
    {
        Var x = blurx.args()[0];
        blurx
            .compute_at(bilateral_grid, x_o)
            .split(x, x_vo, x_vi, 8)
            .vectorize(x_vi);
    }
    {
        Var x = blury.args()[0];
        blury
            .compute_at(bilateral_grid, x_o)
            .split(x, x_vo, x_vi, 8)
            .vectorize(x_vi);
    }
    {
        Var x = blurz.args()[0];
        blurz
            .compute_at(bilateral_grid, x_o)
            .split(x, x_vo, x_vi, 8)
            .vectorize(x_vi);
    }
    {
        Var x = histogram.args()[0];
        RVar r10$x(histogram.update(0).get_schedule().rvars()[0].var);
        RVar r10$y(histogram.update(0).get_schedule().rvars()[1].var);
        histogram
            .compute_at(bilateral_grid, x_o)
            .split(x, x_vo, x_vi, 8)
            .vectorize(x_vi);
        histogram.update(0)
            .reorder(x, r10$x, y, r10$y, c)
            .split(x, x_vo, x_vi, 8, TailStrategy::GuardWithIf)
            .vectorize(x_vi);
    }


}

#endif  // bilateral_grid_auto_schedule_SCHEDULE_H
