module name=bilateral_grid_auto_schedule, target=x86-64-linux-avx-avx2-f16c-fma-no_runtime-sse41
external_plus_metadata func bilateral_grid_auto_schedule (input, r_sigma, bilateral_grid) {
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert((uint64)reinterpret((halide_buffer_t *)bilateral_grid.buffer) != (uint64)0, halide_error_buffer_argument_is_null("bilateral_grid"))
let bilateral_grid = (void *)_halide_buffer_get_host((halide_buffer_t *)bilateral_grid.buffer)
let bilateral_grid.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)bilateral_grid.buffer)
let bilateral_grid.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)bilateral_grid.buffer)
let bilateral_grid.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)bilateral_grid.buffer)
let bilateral_grid.min.0 = _halide_buffer_get_min((halide_buffer_t *)bilateral_grid.buffer, 0)
let bilateral_grid.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)bilateral_grid.buffer, 0)
let bilateral_grid.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)bilateral_grid.buffer, 0)
let bilateral_grid.min.1 = _halide_buffer_get_min((halide_buffer_t *)bilateral_grid.buffer, 1)
let bilateral_grid.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)bilateral_grid.buffer, 1)
let bilateral_grid.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)bilateral_grid.buffer, 1)
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let input.extent.0.required = max(max(min(((((bilateral_grid.extent.0 + bilateral_grid.min.0) + 23)/8)*8) + 4, input.extent.0 + input.min.0), bilateral_grid.extent.0 + bilateral_grid.min.0), input.min.0 + 1) - min(max(min(((min(bilateral_grid.extent.0, 256) + bilateral_grid.min.0)/8)*8, (input.extent.0 + input.min.0) + 275) + -276, input.min.0), (min(bilateral_grid.extent.0, 256) + bilateral_grid.min.0) + -256)
let input.min.0.required = min(max(min(((min(bilateral_grid.extent.0, 256) + bilateral_grid.min.0)/8)*8, (input.extent.0 + input.min.0) + 275) + -276, input.min.0), (min(bilateral_grid.extent.0, 256) + bilateral_grid.min.0) + -256)
let input.extent.1.required = max(max(min(((((bilateral_grid.extent.1 + bilateral_grid.min.1) + 23)/8)*8) + 4, input.extent.1 + input.min.1), bilateral_grid.extent.1 + bilateral_grid.min.1), input.min.1 + 1) - min(max(min(((min(bilateral_grid.extent.1, 256) + bilateral_grid.min.1)/8)*8, (input.extent.1 + input.min.1) + 275) + -276, input.min.1), (min(bilateral_grid.extent.1, 256) + bilateral_grid.min.1) + -256)
let input.min.1.required = min(max(min(((min(bilateral_grid.extent.1, 256) + bilateral_grid.min.1)/8)*8, (input.extent.1 + input.min.1) + 275) + -276, input.min.1), (min(bilateral_grid.extent.1, 256) + bilateral_grid.min.1) + -256)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)bilateral_grid.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)bilateral_grid.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)bilateral_grid.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 2, 32, 2, (halide_dimension_t *)make_struct((min(bilateral_grid.extent.0, 256) + bilateral_grid.min.0) + -256, max(bilateral_grid.extent.0, 256), 1, 0, (min(bilateral_grid.extent.1, 256) + bilateral_grid.min.1) + -256, max(bilateral_grid.extent.1, 256), max(bilateral_grid.extent.0, 256), 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 2, 32, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)bilateral_grid.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer))) {
 assert(bilateral_grid.type == (uint32)73730, halide_error_bad_type("Output buffer bilateral_grid", bilateral_grid.type, (uint32)73730))
 assert(bilateral_grid.dimensions == 2, halide_error_bad_dimensions("Output buffer bilateral_grid", bilateral_grid.dimensions, 2))
 assert(input.type == (uint32)73730, halide_error_bad_type("Input buffer input", input.type, (uint32)73730))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(256 <= bilateral_grid.extent.0, halide_error_access_out_of_bounds("Output buffer bilateral_grid", 0, (min(bilateral_grid.extent.0, 256) + bilateral_grid.min.0) + -256, (bilateral_grid.extent.0 + bilateral_grid.min.0) + -1, bilateral_grid.min.0, (bilateral_grid.extent.0 + bilateral_grid.min.0) + -1))
 assert(256 <= bilateral_grid.extent.1, halide_error_access_out_of_bounds("Output buffer bilateral_grid", 1, (min(bilateral_grid.extent.1, 256) + bilateral_grid.min.1) + -256, (bilateral_grid.extent.1 + bilateral_grid.min.1) + -1, bilateral_grid.min.1, (bilateral_grid.extent.1 + bilateral_grid.min.1) + -1))
 assert((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required + input.min.0.required) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(bilateral_grid.stride.0 == 1, halide_error_constraint_violated("bilateral_grid.stride.0", bilateral_grid.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let bilateral_grid.total_extent.1 = int64(bilateral_grid.extent.1)*int64(bilateral_grid.extent.0)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 assert((uint64)abs(int64(bilateral_grid.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("bilateral_grid", (uint64)abs(int64(bilateral_grid.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(bilateral_grid.extent.1)*int64(bilateral_grid.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("bilateral_grid", (uint64)abs(int64(bilateral_grid.extent.1)*int64(bilateral_grid.stride.1)), (uint64)2147483647))
 assert(bilateral_grid.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("bilateral_grid", bilateral_grid.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(!bilateral_grid.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer bilateral_grid"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(bilateral_grid != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer bilateral_grid"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 produce bilateral_grid {
  let t3402 = 1.000000f/(float32)r_sigma
  let t3403 = min(t3402, 0.000000f)
  let t3404 = max(t3402, 0.000000f)
  let t3405 = input.extent.0 + input.min.0
  let t3406 = (bilateral_grid.extent.0 + 255)/256
  let t3407 = min(max((((((input.min.0 + 27)/8)*8) - bilateral_grid.min.0) + 255)/256, 0), t3406)
  let t3391 = max(min(((((t3405 + -292)/8)*8) - bilateral_grid.min.0) + 255, bilateral_grid.extent.0)/256, t3407)
  let t3389 = (bilateral_grid.extent.1 + 255)/256
  let t3398 = (input.min.1*input.stride.1) + input.min.0
  let t3400 = (bilateral_grid.min.1*bilateral_grid.stride.1) + bilateral_grid.min.0
  let t3397 = input.extent.1 + input.min.1
  let t3393 = int32(t3404)
  let t3394 = int32(t3403)
  let t3395 = int32((t3404 + 0.500000f))
  let t3396 = int32((t3403 + 0.500000f))
  parallel (bilateral_grid.s0.y.y_o, 0, t3389) {
   let bilateral_grid.s0.y.y_i.base.s = min(bilateral_grid.s0.y.y_o*256, bilateral_grid.extent.1 + -256)
   let t3419 = bilateral_grid.min.1 + bilateral_grid.s0.y.y_i.base.s
   let t3420 = t3419/8
   let t3421 = t3420*8
   let t3422 = input.min.1 - t3421
   let t3423 = t3419 % 8
   let t3412 = max(min(min(t3397 - ((((t3423 + 279)/8) + t3420)*8), (t3397 - t3421) + 16), 4), max(min(t3422, -12), -20) + 16)
   let t3408 = max(t3393 + 3, t3395)
   let t3414 = min(bilateral_grid.s0.y.y_o*256, bilateral_grid.extent.1 + -256)
   let t3409 = min(t3394 + -2, t3396)
   let t3410 = (t3423 + 303)/8
   let t3416 = (t3423 + 271)/8
   parallel (bilateral_grid.s0.x.x_o, 0, t3406) {
    if ((t3407 <= bilateral_grid.s0.x.x_o) && (bilateral_grid.s0.x.x_o < t3391)) {
     let bilateral_grid.s0.x.x_i.base.s = min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256)
     let histogram.z.min_realized = min(min(t3394 + -2, t3409), t3396)
     let histogram.z.extent_realized.s.s = max(t3393, t3408)
     let histogram.stride.2 = ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8)*t3410
     allocate histogram[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8) * t3410 * ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1) * 2]
     produce histogram {
      let t3428 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 223)/8
      let t3427 = (((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8
      let t3425 = ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1)*histogram.stride.2
      let t3426 = t3409 - histogram.z.min_realized
      let t3424 = t3408 - t3409
      for (histogram.s0.c, 0, 2) {
       let t3429 = histogram.s0.c*t3425
       for (histogram.s0.z.rebased, 0, t3424 + 1) {
        let t3430 = ((histogram.s0.z.rebased + t3426)*histogram.stride.2) + t3429
        for (histogram.s0.y.rebased, 0, t3410) {
         let t3431 = (histogram.s0.y.rebased*t3427) + t3430
         for (histogram.s0.x.x_vo, 0, 5) {
          histogram[ramp((min((histogram.s0.x.x_vo*8) + -2, t3428) + t3431) + 2, 1, 8)] = x8(0.000000f)
         }
        }
       }
      }
      let t3441 = max(min(t3422, -12), -20)
      let t3442 = bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s
      let t3443 = min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256)
      let t3434 = (-272 - ((bilateral_grid.min.0 + t3443) % 8))/8
      let t3436 = ((t3442 % 8) + 303)/8
      let t3433 = t3442/8
      let t3435 = ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1)*histogram.stride.2
      let t3438 = bilateral_grid.min.1 + t3414
      for (histogram.s1.c, 0, 2) {
       let t3444 = histogram.s1.c*t3435
       for (histogram.s1.r10$y, 0, t3441 + 20) {
        for (histogram.s1.y.rebased, 0, t3410) {
         let t3448 = histogram.s1.y.rebased*t3436
         let t3445 = (max(min(((histogram.s1.y.rebased + t3420)*8) + histogram.s1.r10$y, t3397 + 19) + -20, input.min.1)*input.stride.1) - t3398
         for (histogram.s1.r10$x, 0, 8) {
          let t3449 = histogram.s1.r10$x + t3445
          for (histogram.s1.x.x_vo, 0, 5) {
           let histogram.s1.x.x_vi.base.s = (histogram.s1.x.x_vo*8) + t3433
           if (((histogram.s1.x.x_vo*8) + t3434) <= -5) {
            let t3134.s = input[ramp(((histogram.s1.x.x_vi.base.s*8) + t3449) + -20, 8, 8)]
            let t3135 = ramp(((histogram.s1.x.x_vo*8) + t3448) + t3444, 1, 8) + ((int32x8(((max(min(t3134.s, x8(1.000000f)), x8(0.000000f))*x8(t3402)) + x8(0.500000f))) - x8(histogram.z.min_realized))*x8(histogram.stride.2))
            histogram[t3135] = (float32x8)mux(x8(histogram.s1.c), max(min(t3134.s, x8(1.000000f)), x8(0.000000f)), x8(1.000000f)) + histogram[t3135]
           } else {
            let histogram.s1.x.x_vi.new_max.s = (histogram.s1.x.x_vo*8) + t3434
            let t3451 = 3 - max(histogram.s1.x.x_vi.new_max.s, -5)
            let t3452 = (histogram.s1.x.x_vo*8) + (t3444 + t3448)
            for (histogram.s1.x.x_vi, 0, t3451) {
             let t3136.s = input[(((histogram.s1.x.x_vi + histogram.s1.x.x_vi.base.s)*8) + t3449) + -20]
             let t3137 = (((int32(((max(min(t3136.s, 1.000000f), 0.000000f)*t3402) + 0.500000f)) - histogram.z.min_realized)*histogram.stride.2) + t3452) + histogram.s1.x.x_vi
             histogram[t3137] = (float32)mux(histogram.s1.c, max(min(t3136.s, 1.000000f), 0.000000f), 1.000000f) + histogram[t3137]
            }
           }
          }
         }
        }
       }
       let t3457 = t3438/8
       let t3456 = (((bilateral_grid.min.0 + t3443) % 8) + 47)/8
       let t3455 = histogram.s1.c*t3435
       let t3453 = t3412 - t3441
       let t3454 = max(min((t3457*-8) + input.min.1, -12), -20) + (t3457*8)
       for (histogram.s1.r10$y.rebased, 0, t3453 + -16) {
        let t3458 = histogram.s1.r10$y.rebased + t3454
        for (histogram.s1.y.rebased, 0, t3410) {
         let t3462 = histogram.s1.y.rebased*t3436
         let t3459 = (((histogram.s1.y.rebased*8) + t3458)*input.stride.1) - t3398
         for (histogram.s1.r10$x, 0, 8) {
          let t3463 = histogram.s1.r10$x + t3459
          for (histogram.s1.x.x_vo, 0, 4) {
           let histogram.s1.x.x_vi.base.s = (histogram.s1.x.x_vo*8) + t3433
           let t3139.s = input[ramp(((histogram.s1.x.x_vi.base.s*8) + t3463) + -20, 8, 8)]
           let t3140 = ramp(((histogram.s1.x.x_vo*8) + t3462) + t3455, 1, 8) + ((int32x8(((max(min(t3139.s, x8(1.000000f)), x8(0.000000f))*x8(t3402)) + x8(0.500000f))) - x8(histogram.z.min_realized))*x8(histogram.stride.2))
           histogram[t3140] = (float32x8)mux(x8(histogram.s1.c), max(min(t3139.s, x8(1.000000f)), x8(0.000000f)), x8(1.000000f)) + histogram[t3140]
          }
          let t3465 = t3455 + t3462
          let t3464 = histogram.s1.r10$x + t3459
          for (histogram.s1.x.x_vi, 0, t3456) {
           let t3143.s = input[(((histogram.s1.x.x_vi + t3433)*8) + t3464) + 236]
           let t3144 = (((int32(((max(min(t3143.s, 1.000000f), 0.000000f)*t3402) + 0.500000f)) - histogram.z.min_realized)*histogram.stride.2) + t3465) + histogram.s1.x.x_vi
           histogram[t3144 + 32] = (float32)mux(histogram.s1.c, max(min(t3143.s, 1.000000f), 0.000000f), 1.000000f) + histogram[t3144 + 32]
          }
         }
        }
       }
       let t3467 = histogram.s1.c*t3435
       for (histogram.s1.r10$y.rebased, 0, 4 - t3412) {
        let t3468 = histogram.s1.r10$y.rebased + t3412
        for (histogram.s1.y.rebased, 0, t3410) {
         let t3472 = histogram.s1.y.rebased*t3436
         let t3469 = (max(min(((histogram.s1.y.rebased + t3420)*8) + t3468, t3397 + 15) + -16, input.min.1)*input.stride.1) - t3398
         for (histogram.s1.r10$x, 0, 8) {
          let t3473 = histogram.s1.r10$x + t3469
          for (histogram.s1.x.x_vo, 0, 5) {
           let histogram.s1.x.x_vi.base.s = (histogram.s1.x.x_vo*8) + t3433
           if (((histogram.s1.x.x_vo*8) + t3434) <= -5) {
            let t3145.s = input[ramp(((histogram.s1.x.x_vi.base.s*8) + t3473) + -20, 8, 8)]
            let t3146 = ramp(((histogram.s1.x.x_vo*8) + t3472) + t3467, 1, 8) + ((int32x8(((max(min(t3145.s, x8(1.000000f)), x8(0.000000f))*x8(t3402)) + x8(0.500000f))) - x8(histogram.z.min_realized))*x8(histogram.stride.2))
            histogram[t3146] = (float32x8)mux(x8(histogram.s1.c), max(min(t3145.s, x8(1.000000f)), x8(0.000000f)), x8(1.000000f)) + histogram[t3146]
           } else {
            let histogram.s1.x.x_vi.new_max$2.s = (histogram.s1.x.x_vo*8) + t3434
            let t3475 = 3 - max(histogram.s1.x.x_vi.new_max$2.s, -5)
            let t3476 = (histogram.s1.x.x_vo*8) + (t3467 + t3472)
            for (histogram.s1.x.x_vi, 0, t3475) {
             let t3147.s = input[(((histogram.s1.x.x_vi + histogram.s1.x.x_vi.base.s)*8) + t3473) + -20]
             let t3148 = (((int32(((max(min(t3147.s, 1.000000f), 0.000000f)*t3402) + 0.500000f)) - histogram.z.min_realized)*histogram.stride.2) + t3476) + histogram.s1.x.x_vi
             histogram[t3148] = (float32)mux(histogram.s1.c, max(min(t3147.s, 1.000000f), 0.000000f), 1.000000f) + histogram[t3148]
            }
           }
          }
         }
        }
       }
      }
     }
     allocate blurz[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8) * t3410 * ((t3393 - t3394) + 2) * 2]
     produce blurz {
      consume histogram {
       let t3485 = t3393 - t3394
       let t3478 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 223)/8
       let t3481 = (((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8
       let t3484 = (t3485 + 2)*histogram.stride.2
       let t3479 = ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1)*histogram.stride.2
       let t3480 = t3394 - histogram.z.min_realized
       for (blurz.s0.c, 0, 2) {
        let t3489 = blurz.s0.c*t3484
        let t3486 = blurz.s0.c*t3479
        for (blurz.s0.z.rebased, 0, t3485 + 2) {
         let t3490 = ((blurz.s0.z.rebased + t3480)*histogram.stride.2) + t3486
         let t3493 = (blurz.s0.z.rebased*histogram.stride.2) + t3489
         for (blurz.s0.y.rebased, 0, t3410) {
          let t3498 = blurz.s0.y.rebased*t3481
          let t3497 = t3493 + t3498
          let t3494 = t3490 + t3498
          for (blurz.s0.x.x_vo, 0, 5) {
           let t3149 = min((blurz.s0.x.x_vo*8) + -2, t3478)
           blurz[ramp((t3149 + t3497) + 2, 1, 8)] = histogram[ramp((((histogram.stride.2*2) + t3494) + t3149) + 2, 1, 8)] + ((histogram[ramp(((histogram.stride.2 + t3494) + t3149) + 2, 1, 8)]*x8(4.000000f)) + ((histogram[ramp((t3149 + t3494) + 2, 1, 8)]*x8(6.000000f)) + (histogram[ramp((((histogram.stride.2*-2) + t3494) + t3149) + 2, 1, 8)] + (histogram[ramp(((t3494 - histogram.stride.2) + t3149) + 2, 1, 8)]*x8(4.000000f)))))
          }
         }
        }
       }
      }
     }
     free histogram
     let blurx.stride.2 = ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8)*t3410
     allocate blurx[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8) * t3410 * ((t3393 - t3394) + 2) * 2]
     produce blurx {
      consume blurz {
       let t3505 = t3393 - t3394
       let t3506 = t3505 + 2
       let t3507 = (bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8
       let t3500 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 207)/8
       let t3502 = (t3507 + 303)/8
       let t3504 = (t3507 + 271)/8
       let t3501 = histogram.stride.2*t3506
       let t3503 = blurx.stride.2*t3506
       for (blurx.s0.c, 0, 2) {
        let t3509 = blurx.s0.c*t3503
        let t3508 = blurx.s0.c*t3501
        for (blurx.s0.z.rebased, 0, t3505 + 2) {
         let t3510 = (blurx.s0.z.rebased*histogram.stride.2) + t3508
         let t3511 = (blurx.s0.z.rebased*blurx.stride.2) + t3509
         for (blurx.s0.y.rebased, 0, t3410) {
          let t3513 = (blurx.s0.y.rebased*t3504) + t3511
          let t3512 = (blurx.s0.y.rebased*t3502) + t3510
          for (blurx.s0.x.x_vo, 0, 5) {
           let t3152 = min(blurx.s0.x.x_vo*8, t3500)
           let t3375 = t3152 + t3512
           blurx[ramp(t3152 + t3513, 1, 8)] = blurz[ramp(t3375 + 4, 1, 8)] + ((blurz[ramp(t3375 + 3, 1, 8)]*x8(4.000000f)) + ((blurz[ramp(t3375 + 2, 1, 8)]*x8(6.000000f)) + (blurz[ramp(t3375, 1, 8)] + (blurz[ramp(t3375 + 1, 1, 8)]*x8(4.000000f)))))
          }
         }
        }
       }
      }
     }
     free blurz
     let blury.stride.2 = ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8)*t3416
     allocate blury[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8) * t3416 * ((t3393 - t3394) + 2) * 2]
     produce blury {
      consume blurx {
       let t3520 = t3393 - t3394
       let t3521 = (bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8
       let t3522 = t3520 + 2
       let t3515 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 207)/8
       let t3517 = (t3521 + 271)/8
       let t3519 = blury.stride.2*t3522
       let t3516 = blurx.stride.2*t3522
       for (blury.s0.c, 0, 2) {
        let t3528 = (t3521 + 271)/8
        let t3527 = blury.s0.c*t3519
        let t3523 = blury.s0.c*t3516
        for (blury.s0.z.rebased, 0, t3520 + 2) {
         let t3532 = (blury.s0.z.rebased*blury.stride.2) + t3527
         let t3529 = (blurx.stride.2*blury.s0.z.rebased) + t3523
         for (blury.s0.y.rebased, 0, t3416) {
          let t3533 = ((blury.s0.y.rebased + 2)*t3517) + t3529
          let t3536 = (blury.s0.y.rebased*t3528) + t3532
          for (blury.s0.x.x_vo, 0, 5) {
           let t3157 = min(blury.s0.x.x_vo*8, t3515)
           blury[ramp(t3157 + t3536, 1, 8)] = blurx[ramp(((t3528*2) + t3533) + t3157, 1, 8)] + ((blurx[ramp((t3528 + t3533) + t3157, 1, 8)]*x8(4.000000f)) + ((blurx[ramp(t3157 + t3533, 1, 8)]*x8(6.000000f)) + (blurx[ramp(((t3528*-2) + t3533) + t3157, 1, 8)] + (blurx[ramp((t3533 - t3528) + t3157, 1, 8)]*x8(4.000000f)))))
          }
         }
        }
       }
      }
     }
     free blurx
     consume blury {
      let t3541 = bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s
      let t3542 = t3393 - t3394
      let t3540 = (t3542 + 3)*blury.stride.2
      let t3539 = (t3542 + 2)*blury.stride.2
      let t3538 = t3541 % 8
      for (bilateral_grid.s0.y.y_i, 0, 256) {
       let t3555 = bilateral_grid.s0.y.y_i + t3419
       let t3556 = (t3538 + 271)/8
       let t3557 = t3539 + t3556
       let t3558 = (t3538 + 279)/8
       let t3559 = t3539 + t3558
       let t3544 = ((((t3541 % 8) + 271)/8)*((bilateral_grid.s0.y.y_i + t3423)/8)) - (t3541/8)
       let t3543 = (input.stride.1*t3555) - t3398
       let t3554 = (bilateral_grid.stride.1*t3555) - t3400
       let t3545 = float32((t3555 % 8))
       for (bilateral_grid.s0.x.x_i.x_i_vo, 0, 32) {
        let t3165 = (bilateral_grid.s0.x.x_i.x_i_vo*8) + t3541
        let t3166 = max(min(input[ramp(t3165 + t3543, 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(t3402)
        let t3167 = int32x8(t3166)
        let t3169 = ((int32x8)shift_right(ramp(t3541, 1, 8), x8((uint32)3)) + ((t3167 - x8(t3394))*x8(blury.stride.2))) + x8(bilateral_grid.s0.x.x_i.x_i_vo + t3544)
        let t3170 = float32x8((ramp(t3541, 1, 8) % x8(8)))
        let t3174 = t3166 - float32x8(t3167)
        bilateral_grid[ramp(t3165 + t3554, 1, 8)] = (float32x8)lerp((float32x8)lerp((float32x8)lerp(blury[t3169], blury[t3169 + x8(1)], t3170*x8(0.125000f)), (float32x8)lerp(blury[t3169 + x8(t3556)], blury[t3169 + x8(t3558)], t3170*x8(0.125000f)), x8(t3545*0.125000f)), (float32x8)lerp((float32x8)lerp(blury[t3169 + x8(blury.stride.2)], blury[t3169 + x8(blury.stride.2 + 1)], t3170*x8(0.125000f)), (float32x8)lerp(blury[t3169 + x8(blury.stride.2 + t3556)], blury[t3169 + x8(blury.stride.2 + t3558)], t3170*x8(0.125000f)), x8(t3545*0.125000f)), t3174)/(float32x8)lerp((float32x8)lerp((float32x8)lerp(blury[t3169 + x8(t3539)], blury[t3169 + x8(t3539 + 1)], t3170*x8(0.125000f)), (float32x8)lerp(blury[t3169 + x8(t3557)], blury[t3169 + x8(t3559)], t3170*x8(0.125000f)), x8(t3545*0.125000f)), (float32x8)lerp((float32x8)lerp(blury[t3169 + x8(t3540)], blury[t3169 + x8(t3540 + 1)], t3170*x8(0.125000f)), (float32x8)lerp(blury[t3169 + x8(blury.stride.2 + t3557)], blury[t3169 + x8(blury.stride.2 + t3559)], t3170*x8(0.125000f)), x8(t3545*0.125000f)), t3174)
       }
      }
     }
     free blury
    } else {
     let bilateral_grid.s0.x.x_i.base.s = min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256)
     let histogram.z.min_realized = min(min(t3394 + -2, t3409), t3396)
     let histogram.z.extent_realized.s.s = max(t3393, t3408)
     let histogram.stride.2 = ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8)*t3410
     allocate histogram[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8) * t3410 * ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1) * 2]
     produce histogram {
      let t3564 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 223)/8
      let t3563 = (((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8
      let t3561 = ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1)*histogram.stride.2
      let t3562 = t3409 - histogram.z.min_realized
      let t3560 = t3408 - t3409
      for (histogram.s0.c, 0, 2) {
       let t3565 = histogram.s0.c*t3561
       for (histogram.s0.z.rebased, 0, t3560 + 1) {
        let t3566 = ((histogram.s0.z.rebased + t3562)*histogram.stride.2) + t3565
        for (histogram.s0.y.rebased, 0, t3410) {
         let t3567 = (histogram.s0.y.rebased*t3563) + t3566
         for (histogram.s0.x.x_vo, 0, 5) {
          histogram[ramp((min((histogram.s0.x.x_vo*8) + -2, t3564) + t3567) + 2, 1, 8)] = x8(0.000000f)
         }
        }
       }
      }
      let t3572 = bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s
      let t3569 = (-272 - ((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8))/8
      let t3571 = ((t3572 % 8) + 303)/8
      let t3568 = t3572/8
      let t3570 = ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1)*histogram.stride.2
      for (histogram.s1.c, 0, 2) {
       let t3573 = histogram.s1.c*t3570
       for (histogram.s1.r10$y, 0, 8) {
        for (histogram.s1.y.rebased, 0, t3410) {
         let t3577 = histogram.s1.y.rebased*t3571
         let t3574 = (max(min(((histogram.s1.y.rebased + t3420)*8) + histogram.s1.r10$y, t3397 + 19) + -20, input.min.1)*input.stride.1) - t3398
         for (histogram.s1.r10$x, 0, 8) {
          for (histogram.s1.x.x_vo, 0, 5) {
           let histogram.s1.x.x_vi.base.s = (histogram.s1.x.x_vo*8) + t3568
           if (((histogram.s1.x.x_vo*8) + t3569) <= -5) {
            let t3178.s = input[max(min(ramp(((histogram.s1.x.x_vi.base.s*8) + histogram.s1.r10$x) + -20, 8, 8), x8(t3405 + -1)), x8(input.min.0)) + x8(t3574)]
            let t3179 = ramp(((histogram.s1.x.x_vo*8) + t3577) + t3573, 1, 8) + ((int32x8(((max(min(t3178.s, x8(1.000000f)), x8(0.000000f))*x8(t3402)) + x8(0.500000f))) - x8(histogram.z.min_realized))*x8(histogram.stride.2))
            histogram[t3179] = (float32x8)mux(x8(histogram.s1.c), max(min(t3178.s, x8(1.000000f)), x8(0.000000f)), x8(1.000000f)) + histogram[t3179]
           } else {
            let histogram.s1.x.x_vi.new_max$3.s = (histogram.s1.x.x_vo*8) + t3569
            let t3579 = 3 - max(histogram.s1.x.x_vi.new_max$3.s, -5)
            let t3580 = (histogram.s1.x.x_vo*8) + (t3573 + t3577)
            for (histogram.s1.x.x_vi, 0, t3579) {
             let t3180.s = input[max(min(((histogram.s1.x.x_vi + histogram.s1.x.x_vi.base.s)*8) + histogram.s1.r10$x, t3405 + 19) + -20, input.min.0) + t3574]
             let t3181 = (((int32(((max(min(t3180.s, 1.000000f), 0.000000f)*t3402) + 0.500000f)) - histogram.z.min_realized)*histogram.stride.2) + t3580) + histogram.s1.x.x_vi
             histogram[t3181] = (float32)mux(histogram.s1.c, max(min(t3180.s, 1.000000f), 0.000000f), 1.000000f) + histogram[t3181]
            }
           }
          }
         }
        }
       }
      }
     }
     allocate blurz[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8) * t3410 * ((t3393 - t3394) + 2) * 2]
     produce blurz {
      consume histogram {
       let t3589 = t3393 - t3394
       let t3582 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 223)/8
       let t3585 = (((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 303)/8
       let t3588 = (t3589 + 2)*histogram.stride.2
       let t3583 = ((histogram.z.extent_realized.s.s - histogram.z.min_realized) + 1)*histogram.stride.2
       let t3584 = t3394 - histogram.z.min_realized
       for (blurz.s0.c, 0, 2) {
        let t3593 = blurz.s0.c*t3588
        let t3590 = blurz.s0.c*t3583
        for (blurz.s0.z.rebased, 0, t3589 + 2) {
         let t3594 = ((blurz.s0.z.rebased + t3584)*histogram.stride.2) + t3590
         let t3597 = (blurz.s0.z.rebased*histogram.stride.2) + t3593
         for (blurz.s0.y.rebased, 0, t3410) {
          let t3602 = blurz.s0.y.rebased*t3585
          let t3601 = t3597 + t3602
          let t3598 = t3594 + t3602
          for (blurz.s0.x.x_vo, 0, 5) {
           let t3182 = min((blurz.s0.x.x_vo*8) + -2, t3582)
           blurz[ramp((t3182 + t3601) + 2, 1, 8)] = histogram[ramp((((histogram.stride.2*2) + t3598) + t3182) + 2, 1, 8)] + ((histogram[ramp(((histogram.stride.2 + t3598) + t3182) + 2, 1, 8)]*x8(4.000000f)) + ((histogram[ramp((t3182 + t3598) + 2, 1, 8)]*x8(6.000000f)) + (histogram[ramp((((histogram.stride.2*-2) + t3598) + t3182) + 2, 1, 8)] + (histogram[ramp(((t3598 - histogram.stride.2) + t3182) + 2, 1, 8)]*x8(4.000000f)))))
          }
         }
        }
       }
      }
     }
     free histogram
     let blurx.stride.2 = ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8)*t3410
     allocate blurx[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8) * t3410 * ((t3393 - t3394) + 2) * 2]
     produce blurx {
      consume blurz {
       let t3609 = t3393 - t3394
       let t3610 = t3609 + 2
       let t3611 = (bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8
       let t3604 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 207)/8
       let t3606 = (t3611 + 303)/8
       let t3608 = (t3611 + 271)/8
       let t3605 = histogram.stride.2*t3610
       let t3607 = blurx.stride.2*t3610
       for (blurx.s0.c, 0, 2) {
        let t3613 = blurx.s0.c*t3607
        let t3612 = blurx.s0.c*t3605
        for (blurx.s0.z.rebased, 0, t3609 + 2) {
         let t3614 = (blurx.s0.z.rebased*histogram.stride.2) + t3612
         let t3615 = (blurx.s0.z.rebased*blurx.stride.2) + t3613
         for (blurx.s0.y.rebased, 0, t3410) {
          let t3617 = (blurx.s0.y.rebased*t3608) + t3615
          let t3616 = (blurx.s0.y.rebased*t3606) + t3614
          for (blurx.s0.x.x_vo, 0, 5) {
           let t3185 = min(blurx.s0.x.x_vo*8, t3604)
           let t3382 = t3185 + t3616
           blurx[ramp(t3185 + t3617, 1, 8)] = blurz[ramp(t3382 + 4, 1, 8)] + ((blurz[ramp(t3382 + 3, 1, 8)]*x8(4.000000f)) + ((blurz[ramp(t3382 + 2, 1, 8)]*x8(6.000000f)) + (blurz[ramp(t3382, 1, 8)] + (blurz[ramp(t3382 + 1, 1, 8)]*x8(4.000000f)))))
          }
         }
        }
       }
      }
     }
     free blurz
     let blury.stride.2 = ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8)*t3416
     allocate blury[float32 * ((((bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8) + 271)/8) * t3416 * ((t3393 - t3394) + 2) * 2]
     produce blury {
      consume blurx {
       let t3624 = t3393 - t3394
       let t3625 = (bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s) % 8
       let t3626 = t3624 + 2
       let t3619 = (((min(bilateral_grid.s0.x.x_o*256, bilateral_grid.extent.0 + -256) + bilateral_grid.min.0) % 8) + 207)/8
       let t3621 = (t3625 + 271)/8
       let t3623 = blury.stride.2*t3626
       let t3620 = blurx.stride.2*t3626
       for (blury.s0.c, 0, 2) {
        let t3632 = (t3625 + 271)/8
        let t3631 = blury.s0.c*t3623
        let t3627 = blury.s0.c*t3620
        for (blury.s0.z.rebased, 0, t3624 + 2) {
         let t3636 = (blury.s0.z.rebased*blury.stride.2) + t3631
         let t3633 = (blurx.stride.2*blury.s0.z.rebased) + t3627
         for (blury.s0.y.rebased, 0, t3416) {
          let t3637 = ((blury.s0.y.rebased + 2)*t3621) + t3633
          let t3640 = (blury.s0.y.rebased*t3632) + t3636
          for (blury.s0.x.x_vo, 0, 5) {
           let t3190 = min(blury.s0.x.x_vo*8, t3619)
           blury[ramp(t3190 + t3640, 1, 8)] = blurx[ramp(((t3632*2) + t3637) + t3190, 1, 8)] + ((blurx[ramp((t3632 + t3637) + t3190, 1, 8)]*x8(4.000000f)) + ((blurx[ramp(t3190 + t3637, 1, 8)]*x8(6.000000f)) + (blurx[ramp(((t3632*-2) + t3637) + t3190, 1, 8)] + (blurx[ramp((t3637 - t3632) + t3190, 1, 8)]*x8(4.000000f)))))
          }
         }
        }
       }
      }
     }
     free blurx
     consume blury {
      let t3645 = bilateral_grid.min.0 + bilateral_grid.s0.x.x_i.base.s
      let t3646 = t3393 - t3394
      let t3644 = (t3646 + 3)*blury.stride.2
      let t3643 = (t3646 + 2)*blury.stride.2
      let t3642 = t3645 % 8
      for (bilateral_grid.s0.y.y_i, 0, 256) {
       let t3659 = bilateral_grid.s0.y.y_i + t3419
       let t3660 = (t3642 + 271)/8
       let t3661 = t3643 + t3660
       let t3662 = (t3642 + 279)/8
       let t3663 = t3643 + t3662
       let t3648 = ((((t3645 % 8) + 271)/8)*((bilateral_grid.s0.y.y_i + t3423)/8)) - (t3645/8)
       let t3647 = (input.stride.1*t3659) - t3398
       let t3658 = (bilateral_grid.stride.1*t3659) - t3400
       let t3649 = float32((t3659 % 8))
       for (bilateral_grid.s0.x.x_i.x_i_vo, 0, 32) {
        let t3198 = (bilateral_grid.s0.x.x_i.x_i_vo*8) + t3645
        let t3199 = max(min(input[ramp(t3198 + t3647, 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(t3402)
        let t3200 = int32x8(t3199)
        let t3202 = ((int32x8)shift_right(ramp(t3645, 1, 8), x8((uint32)3)) + ((t3200 - x8(t3394))*x8(blury.stride.2))) + x8(bilateral_grid.s0.x.x_i.x_i_vo + t3648)
        let t3203 = float32x8((ramp(t3645, 1, 8) % x8(8)))
        let t3207 = t3199 - float32x8(t3200)
        bilateral_grid[ramp(t3198 + t3658, 1, 8)] = (float32x8)lerp((float32x8)lerp((float32x8)lerp(blury[t3202], blury[t3202 + x8(1)], t3203*x8(0.125000f)), (float32x8)lerp(blury[t3202 + x8(t3660)], blury[t3202 + x8(t3662)], t3203*x8(0.125000f)), x8(t3649*0.125000f)), (float32x8)lerp((float32x8)lerp(blury[t3202 + x8(blury.stride.2)], blury[t3202 + x8(blury.stride.2 + 1)], t3203*x8(0.125000f)), (float32x8)lerp(blury[t3202 + x8(blury.stride.2 + t3660)], blury[t3202 + x8(blury.stride.2 + t3662)], t3203*x8(0.125000f)), x8(t3649*0.125000f)), t3207)/(float32x8)lerp((float32x8)lerp((float32x8)lerp(blury[t3202 + x8(t3643)], blury[t3202 + x8(t3643 + 1)], t3203*x8(0.125000f)), (float32x8)lerp(blury[t3202 + x8(t3661)], blury[t3202 + x8(t3663)], t3203*x8(0.125000f)), x8(t3649*0.125000f)), (float32x8)lerp((float32x8)lerp(blury[t3202 + x8(t3644)], blury[t3202 + x8(t3644 + 1)], t3203*x8(0.125000f)), (float32x8)lerp(blury[t3202 + x8(blury.stride.2 + t3661)], blury[t3202 + x8(blury.stride.2 + t3663)], t3203*x8(0.125000f)), x8(t3649*0.125000f)), t3207)
       }
      }
     }
     free blury
    }
   }
  }
 }
}
}


